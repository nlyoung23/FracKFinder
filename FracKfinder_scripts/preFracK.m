clear all
close all

%=======================================================================
%= FracKFinder: A 3-D K Tensor-Determining Program for HydroGeoSphere ==
%=============== By Nathan Young and Jacqueline Reber ==================
%========================Preprocessor Notes=============================

%This code consists of two scripts which, when run together, allow for the 
%determination of a 3-D K tensor for a cube of fractured media using
%HydroGeoSphere (HGS). The preprocessor generates all of the necessary model 
%input, and then runs an ensemble of 78 flow simulations. Required user 
%input is minimal, but the user must either provide a fractured grid, 
%or specify that one be generated by HydroGeoSphere using a constant seed 
%number. The user must also supply the matrix properties file (.mprops) and
%the fracture properties file (.fprops). The .grok file used for all model
%simulations is located in the in the _MASTER file, and should be edited by
%the user according to the instructions at the top of the file. All other
%required input is generated by this script. This script will write 78
%different copies of the following: .grok files, head gradient files, batch 
%files, and hsplot files. The script will also initialize in sequence, the
%Grok, HGS, and HSPLOT executables. This will format the output in the
%required manner for the use of the second script, the Postprocessor.
%
% 
%===================================
%====REQUIRED USER INPUT============
%===================================
%In this folder titled "Model_Runs", place the Hydrogeosphere executeables: grok.exe, phgs.exe,
%hsplot.exe. In the subfolder titled "_props," place the hydrogeosphere grid files, the .mprops file,
%and the .fprops file, as well as the .ginc file (if using)

%Write the directory location for the _User_Files folder below:

cd 'C:\Users\nlyoung\Desktop\FracKfinder\Example' % <---- IMPORTANT! If this filepath is incorrect, the whole code will not run!

%_User input variables____

%_Grid Geometry___________
%Use a grid_spec of 1 if (0,0) is in the lower left corner of the grid
%Use a grid_spec of 2 if (0,0) is the center of the grid

grid_spec = 2;

%Input side length of sample

x = 2;

%_Nodal spacing__________

%input the constant distance between two nodes in your model

node_spacing= 0.02;

%===================================================
%====NO USER INPUT REQUIRED AFTER THIS LINE=========
%===================================================
%=================THE CODE==========================
%===================================================

tic

n_nodes =( x/node_spacing); %number of nodes on a side of the sample

n = (x/node_spacing)+1;

head_rotation_magnitudes = csvread('headrotationmagnitudes.csv'); %a matrix of numbers that scale a unit hydraulic gradient by the requisite amount to mimic rotating the gradient plane
heads = head_rotation_magnitudes*x; %multiplies the scaling factor by the lenght of the sample to get a sample-specific set of rotated unit gradients
csvwrite('grads1.csv',heads); %writes the gradient file for use in the postprocessor script

%head vector inputs

%create boundary condition block selections

if grid_spec == 1
    
    xleft = {[0,0],[0,x],[0,x]}';
    xright = {[x,x],[0,x],[0,x]}';
    
    yback = {[0,x],[0,0],[0,x]}';
    yfront = {[0,x],[x,x],[0,x]}';
    
    ztop = {[0,x],[0,x],[0,0]}';
    zbottom = {[0,x],[0,x],[x,x]}';
    
else
    
    xhalf=x/2;
    
    xleft = {[-xhalf,-xhalf],[-xhalf,xhalf],[-xhalf,xhalf]}';
    xright = {[xhalf,xhalf],[-xhalf,xhalf],[-xhalf,xhalf]}';
    
    yback = {[-xhalf,xhalf],[-xhalf,-xhalf],[-xhalf,xhalf]}';
    yfront = {[-xhalf,xhalf],[xhalf,xhalf],[-xhalf,xhalf]}';
    
    ztop = {[-xhalf,xhalf],[-xhalf,xhalf],[-xhalf,-xhalf]}';
    zbottom = {[-xhalf,xhalf],[-xhalf,xhalf],[xhalf,xhalf]}';   
end


nn=(n_nodes+1).^2;
hi15= x+(x*0.15); %starting head value for 15 degree rotation
lo15= x-(x*0.15); %ending head value for 15 degree rotation
by15 = (hi15-lo15)/(n_nodes);
h15 = lo15:by15:hi15;

hi30= x+(x*0.30); %starting head value for 30 degree rotation
lo30= x-(x*0.30); %ending head value for 30 degree rotation
by30 = (hi30-lo30)/(n_nodes);
h30 = lo30:by30:hi30;

hi60= x+(x*0.60); %starting head value for 60 degree rotation
lo60= x-(x*0.60); %ending head value for 60 degree rotation
by60 = (hi60-lo60)/(n_nodes);
h60 = lo60:by60:hi60;

ini = ones(1,nn);
unit = ini*x; %create unit gradient file


 v15 = repelem(h15,n).'; %have head change in y direction instead of x
 v30 = repelem(h30,n).';
 v60 = repelem(h60,n).';
 vm15 = flipud(v15); %mirror above
 vm30 = flipud(v30);
 vm60 = flipud(v60);

 s = (ones((n^2),1))*x;
 
 bv15 = v15 - s;
 bv30 = v30 - s;
 bv60 = v60 - s;
 bvm15 = vm15 - s;
 bvm30 = vm60 - s;
 bvm60 = vm60 - s;
 
 c_bv = {bv15,bv30,bv60};
 c_bmv = {bvm15,bvm30,bvm60};
 
 

zero = zeros(1,n_nodes+1)';
zeros=repmat(zero,n_nodes+1,1);
unit3d = {unit'};
heads2d = {h15,h30,h60};
mirror_heads2d = cellfun(@fliplr,heads2d,'UniformOutput',false);
vertical_heads2d = {h15',h30',h60'};
vertical_mirror_heads2d = cellfun(@transpose,mirror_heads2d,'UniformOutput',false);



for m=1:length(heads2d)
    
    heads3d{m}=repmat(heads2d{m},n_nodes+1,1);
    vert_heads3d{m} = repmat(vertical_heads2d{m},1,n_nodes+1);
    mirror_heads3d{m} = repmat(mirror_heads2d{m},n_nodes+1,1);
    vert_mirror_heads3d{m} = repmat(vertical_mirror_heads2d{m},1,n_nodes+1);
    
end

% correct_heads = cellfun(@transpose,heads3d,'UniformOutput',false);
% correct_mirror = cellfun(@transpose,mirror_heads3d,'UniformOutput',false);


%reshape vertical head gradient rotation files
 for z=1:3
     correct_vert{1,z}=reshape(heads3d{1,z},nn,1);
     correct_vertm{1,z}=reshape(mirror_heads3d{1,z},nn,1);
     correct_heads{1,z}=reshape(vert_heads3d{1,z},nn,1);
     correct_mirror{1,z}=reshape(vert_mirror_heads3d{1,z},nn,1);
 end
% %create head file titles  

%create bottom input files
A = (ones(1,n_nodes+1)*x);
sub = {A,A,A};
subv = repmat(A,n_nodes+1);
AA = {(ones(n_nodes+1,n_nodes+1)*x)};
AAA= [AA,AA,AA];

 
bottom_heads = cellfun(@minus,heads3d,AAA,'UniformOutput',false);
bottom_mirror = cellfun(@minus,mirror_heads3d,AAA,'UniformOutput',false);
bottom_vert = cellfun(@minus,vert_heads3d,AAA,'UniformOutput',false);
bottom_vert_mirror = cellfun(@minus,vert_mirror_heads3d,AAA,'UniformOutput',false);

for z=1:3
     correct_bottom_vert{1,z}=reshape(bottom_heads{1,z},nn,1);
     correct_bottom_vertm{1,z}=reshape(bottom_mirror{1,z},nn,1);
     correct_bottom_heads{1,z}=reshape(bottom_vert{1,z},nn,1);
     correct_bottom_mirror{1,z}=reshape(bottom_vert_mirror{1,z},nn,1);
end

header = nn;

re_order15={correct_heads{1,1},correct_bottom_heads{1,1},correct_mirror{1,1},correct_bottom_mirror{1,1},correct_vert{1,1},c_bv{1,1},correct_vertm{1,1},c_bmv{1,1}};
re_order30={correct_heads{1,2},correct_bottom_heads{1,2},correct_mirror{1,2},correct_bottom_mirror{1,2},correct_vert{1,2},c_bv{1,2},correct_vertm{1,2},c_bmv{1,2}};
re_order60={correct_heads{1,3},correct_bottom_heads{1,3},correct_mirror{1,3},correct_bottom_mirror{1,3},correct_vert{1,3},c_bv{1,3},correct_vertm{1,3},c_bmv{1,3}};

All_heads={unit3d{1,1},zeros,re_order15{1,:},re_order30{1,:},re_order60{1,:}};

for z=1:26
    if mod(z, 2) == 0  
    correct_headsodd{1,z}=All_heads{1,z};
    else
    correct_headseven{1,z}=All_heads{1,z}; 
    end
end

correct_headsodd = correct_headsodd(~cellfun('isempty',correct_headsodd));
correct_headseven = correct_headseven(~cellfun('isempty',correct_headseven));

for cc = 1:26
    if mod(cc, 2) == 0  
    if cc<10
     hft{cc} = sprintf('0%d.txt', cc);
    else
     hft{cc} = sprintf('%d.txt', cc);
    end
    else
    if cc<10
     hfb{cc} = {sprintf('0%d.txt', cc)};
    else
     hfb{cc} = {sprintf('%d.txt', cc)};
    end     
    end
    
end

nb = hfb(~cellfun('isempty',hfb));
nt = hft(~cellfun('isempty',hft));

 for dd = 1:13    
       title = char(nb{dd});
     dlmwrite(title,header,'delimiter','','newline','pc')
     dlmwrite(title,correct_headseven(1,dd),'delimiter',' ','precision','%.3f','newline','pc','-append'); 
           
        titlet = char(nt{dd});
     dlmwrite(titlet,header,'delimiter','','newline','pc')
     dlmwrite(titlet,correct_headsodd(1,dd),'delimiter',' ','precision','%.3f','newline','pc','-append');   
 end 

grokfile1 = regexp( fileread('grok_template.grok'), '\n', 'split');
grokfile = grokfile1';
hfc = regexp( fileread('headfilecall.txt'), '\n', 'split'); %This is the file containing the boundary condition information 

%x runs
for k = 1:26
    if k<10
        xfilename = sprintf('0%d.grok', k);
    else
        xfilename = sprintf('%d.grok', k);
    end
    if mod(k, 2) == 0
        
        grokfile{132,1} = num2str(xleft{1});
        grokfile{133,1} = num2str(xleft{2}) ;
        grokfile{134,1} = num2str(xleft{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(xright{1});
        grokfile{160,1} = num2str(xright{2});
        grokfile{161,1} = num2str(xright{3});
        grokfile{178,1} = char(hfc{(k-1)});
        grokfile{215,1} = num2str(xleft{1});
        grokfile{216,1} = num2str(xleft{2}) ;
        grokfile{217,1} = num2str(xleft{3});
    else
        grokfile{132,1} = num2str(xleft{1});
        grokfile{133,1} = num2str(xleft{2}) ;
        grokfile{134,1} = num2str(xleft{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(xright{1});
        grokfile{160,1} = num2str(xright{2});
        grokfile{161,1} = num2str(xright{3});
        grokfile{178,1} = char(hfc{k+1});
        grokfile{215,1} = num2str(xright{1});
        grokfile{216,1} = num2str(xright{2}) ;
        grokfile{217,1} = num2str(xright{3});
    end
    
    fileID = fopen(xfilename,'w');
    cstr = grokfile;
    fprintf(1, '%s', cstr{:});
    fprintf(1, '\n');
    fprintf(fileID,'%s\n',cstr{:});
    fclose(fileID);
    
    fid2 = fopen('batch.pfx','w');
    if k<10
        batchnum = ['0' num2str(k)];
    else
        batchnum = num2str(k);
    end
    fprintf(fid2,batchnum);
    fclose(fid2);
   
   
    system('grok.exe')
    system('phgs.exe')
    system('hsplot.exe')
    
end

%y runs
for k = 27:52
    xfilename = sprintf('%d.grok', k);
    if mod(k, 2) == 0
        grokfile{132,1} = num2str(yback{1});
        grokfile{133,1} = num2str(yback{2}) ;
        grokfile{134,1} = num2str(yback{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(yfront{1});
        grokfile{160,1} = num2str(yfront{2});
        grokfile{161,1} = num2str(yfront{3});
        grokfile{178,1} = char(hfc{(k-1)});
        grokfile{215,1} = num2str(yback{1});
        grokfile{216,1} = num2str(yback{2}) ;
        grokfile{217,1} = num2str(yback{3});
    else
        grokfile{132,1} = num2str(yback{1});
        grokfile{133,1} = num2str(yback{2}) ;
        grokfile{134,1} = num2str(yback{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(yfront{1});
        grokfile{160,1} = num2str(yfront{2});
        grokfile{161,1} = num2str(yfront{3});
        grokfile{178,1} = char(hfc{k+1});
        grokfile{215,1} = num2str(yfront{1});
        grokfile{216,1} = num2str(yfront{2}) ;
        grokfile{217,1} = num2str(yfront{3});
    end
    
    fileID = fopen(xfilename,'w');
    cstr = grokfile;
    fprintf(1, '%s', cstr{:});
    fprintf(1, '\n');
    fprintf(fileID,'%s\n',cstr{:});
    fclose(fileID);
    
    fid2 = fopen('batch.pfx','w');
    batchnum = num2str(k);
    fprintf(fid2,batchnum);
    fclose(fid2);
 
  
    system('grok.exe')
    system('phgs.exe')
    system('hsplot.exe')
    
end

%z runs

for k = 53:78
    xfilename = sprintf('%d.grok', k);
    if mod(k, 2) == 0
        grokfile{132,1} = num2str(ztop{1});
        grokfile{133,1} = num2str(ztop{2}) ;
        grokfile{134,1} = num2str(ztop{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(zbottom{1});
        grokfile{160,1} = num2str(zbottom{2});
        grokfile{161,1} = num2str(zbottom{3});
        grokfile{178,1} = char(hfc{(k-1)});
        grokfile{215,1} = num2str(zbottom{1});
        grokfile{216,1} = num2str(zbottom{2}) ;
        grokfile{217,1} = num2str(zbottom{3});
    else
        grokfile{132,1} = num2str(ztop{1});
        grokfile{133,1} = num2str(ztop{2}) ;
        grokfile{134,1} = num2str(ztop{3});
        grokfile{151,1} = char(hfc{k});
        grokfile{159,1} = num2str(zbottom{1});
        grokfile{160,1} = num2str(zbottom{2});
        grokfile{161,1} = num2str(zbottom{3});
        grokfile{178,1} = char(hfc{k+1});
        grokfile{215,1} = num2str(ztop{1});
        grokfile{216,1} = num2str(ztop{2}) ;
        grokfile{217,1} = num2str(ztop{3});
    end
        
    fileID = fopen(xfilename,'w');
    cstr = grokfile;
    fprintf(1, '%s', cstr{:});
    fprintf(1, '\n');
    fprintf(fileID,'%s\n',cstr{:});
    fclose(fileID);
    
    fid2 = fopen('batch.pfx','w');
    batchnum = num2str(k);
    fprintf(fid2,batchnum);
    fclose(fid2);
    
    system('grok.exe')
    system('phgs.exe')
    system('hsplot.exe')
    
end
toc